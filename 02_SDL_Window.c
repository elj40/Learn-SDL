/*
* Filename:	02_SDL_Window.c
* Date:		19/11/2024 
* Name:		EL Joubert
*
* Make and display an empty window with custom colors
*/

#include <stdio.h>
#include <SDL2/SDL.h>

#define WINDOW_WIDTH 1280
#define WINDOW_HEIGHT 720
// main has to take arguments
int main(int argc, char * argv[]) {
	SDL_Init(SDL_INIT_VIDEO);	
	// Current screen resolution: 1920*1080
	SDL_Window * window =  SDL_CreateWindow("SDL Window", 
			SDL_WINDOWPOS_UNDEFINED, 
			SDL_WINDOWPOS_UNDEFINED, 
			WINDOW_WIDTH, 
			WINDOW_HEIGHT, 
			SDL_WINDOW_RESIZABLE);

	if (window == NULL) {
		printf("Failed to create window: %s\n", SDL_GetError());
		return 1;
	}


/**
 * Get the SDL surface associated with the window.
 * This surface will be invalidated if the window is resized. After resizing a
 * window this function must be called again to return a valid surface.
 */
	SDL_Surface *  surface = SDL_GetWindowSurface(window);
	if (surface == NULL) 
	{
		printf("Failed to create surface: %s\n", SDL_GetError());
		return 1;
	}

	
/**
 * Map an RGB triple to an opaque pixel value for a given pixel format.
 * If the pixel format bpp (color depth) is less than 32-bpp then the unused
 * upper bits of the return value can safely be ignored (e.g., with a 16-bpp
 * format the return value can be assigned to a Uint16, and similarly a Uint8
 * for an 8-bpp format).
 *
 * \param format an SDL_PixelFormat structure describing the pixel format
 * \param r the red component of the pixel in the range 0-255
 * \param g the green component of the pixel in the range 0-255
 * \param b the blue component of the pixel in the range 0-255
 * \returns a pixel value
 */
	// Have to update the surface format for it to work for some reason
	Uint32 color = SDL_MapRGB(surface->format, 100, 255, 60);


/**
 * Perform a fast fill of a rectangle with a specific color.
 *
 * `color` should be a pixel of the format used by the surface, and can be
 * generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
 * alpha component then the destination is simply filled with that alpha
 * information, no blending takes place.
 *
 * If there is a clip rectangle set on the destination (set via
 * SDL_SetClipRect()), then this function will fill based on the intersection
 * of the clip rectangle and `rect`.
 *
 * \param dst the SDL_Surface structure that is the drawing target
 * \param rect the SDL_Rect structure representing the rectangle to fill, or
 *             NULL to fill the entire surface
 * \param color the color to fill with
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_FillRects
 * typedef struct SDL_Rect
 * {
 *   int x, y;
 *   int w, h;
 * } SDL_Rect;
 */
	const SDL_Rect surface_rect = {0,0, WINDOW_WIDTH, WINDOW_HEIGHT};

	SDL_FillRect(surface, &surface_rect ,color);

/**
 * Copy the window surface to the screen.
 *
 * This is the function you use to reflect any changes to the surface on the
 * screen.
 *
 * This function is equivalent to the SDL 1.2 API SDL_Flip().
 *
 * \param window the window to update
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetWindowSurface
 * \sa SDL_UpdateWindowSurfaceRects
 */

	int lifetime = 10000;

	while (lifetime > 0) {
		lifetime--;
		SDL_UpdateWindowSurface(window);
	}

	SDL_DestroyWindow(window);

	return 0;
}

